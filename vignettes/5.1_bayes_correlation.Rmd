---
title: "Bayesian Correlation"
author: "Niklas Rindtorff"
date: "4/15/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

```{r}
library(here)
library(tidyverse)

source(here("../bayes/robust_correlation/rob.cor.mcmc.R"))

library(rstan)    # to run the Bayesian model (stan)
library(coda)     # to obtain HPD intervals (HPDinterval)
library(mvtnorm)  # to generate random correlated data (rmvnorm)
library(car) 
library(gridExtra)
library(furrr)

library(microbenchmark)

rstan_options(auto_write = TRUE)


cor_iter_df_fd <- readRDS(here("data/cor_iter_df_fd.Rds"))
cor_pan <- readRDS(here("data/cor_pan.Rds"))
load(here("data/crxg.Rdata"))
load(here("data/mutation.Rdata"))
covariates <- read_csv(here("data/covariates.csv"))

```

Define STAN model 

```{r, eval = TRUE}
# Stan model definition
  stan.model = "
  data {
  int<lower=1> N;  // number of observations
  vector[2] x[N];  // input data: rows are observations, columns are the two variables
  }
  
  parameters {
  vector[2] mu;                 // locations of the marginal t distributions
  real<lower=0> sigma[2];       // scales of the marginal t distributions
  real<lower=1> nu;             // degrees of freedom of the marginal t distributions
  real<lower=-1, upper=1> rho;  // correlation coefficient
  }
  
  transformed parameters {
  // Covariance matrix
  cov_matrix[2] cov = [[      sigma[1] ^ 2       , sigma[1] * sigma[2] * rho],
  [sigma[1] * sigma[2] * rho,       sigma[2] ^ 2       ]];
  }
  
  model {
  // Likelihood
  // Bivariate Student's t-distribution instead of normal for robustness
  x ~ multi_student_t(nu, mu, cov);
  
  // Noninformative priors on all parameters
  sigma ~ normal(0, 1000);
  mu ~ normal(0, 1000);
  nu ~ gamma(2, 0.1);
  }
  
  generated quantities {
  // Random samples from the estimated bivariate t-distribution (for assessment of fit)
  vector[2] x_rand;
  x_rand = multi_student_t_rng(nu, mu, cov);
  }"
```

```{r, eval = TRUE}
correlation_model <- stan_model(model_code = stan.model,
                                model_name="robust_correlation")
```




Define STAN model 

```{r}
# Stan model definition
  stan.model = "
  data {
  int<lower=1> N;  // number of observations
  vector[2] x[N];  // input data: rows are observations, columns are the two variables
  }
  
  parameters {
  vector[2] mu;                 // locations of the marginal t distributions
  real<lower=0> sigma[2];       // scales of the marginal t distributions
  real<lower=1> nu;             // degrees of freedom of the marginal t distributions
  real<lower=-1, upper=1> rho;  // correlation coefficient
  }
  
  transformed parameters {
  // Covariance matrix
  cov_matrix[2] cov = [[      sigma[1] ^ 2       , sigma[1] * sigma[2] * rho],
  [sigma[1] * sigma[2] * rho,       sigma[2] ^ 2       ]];
  }
  
  model {
  // Likelihood
  // Bivariate Student's t-distribution instead of normal for robustness
  x ~ multi_student_t(nu, mu, cov);
  
  // Noninformative priors on all parameters
  sigma ~ normal(0, 1000);
  mu ~ normal(0, 1000);
  nu ~ gamma(2, 0.1);
  }
  
  generated quantities {
  // Random samples from the estimated bivariate t-distribution (for assessment of fit)
  vector[2] x_rand;
  x_rand = multi_student_t_rng(nu, mu, cov);
  }"
```

```{r}
correlation_model <- stan_model(model_code = stan.model,
                                model_name="robust_correlation")
```


```{r}
tidy_mcmc_cor <- function(var1, var2, df = crxg, model_in = correlation_model){
df %>% 
    filter(drug_id == var1 | drug_id == var2) %>% 
    select(drug_id, cosmic_id, norm_ln_ic50) %>% 
    spread(drug_id, norm_ln_ic50) %>% 
  drop_na() %>% 
  dplyr::select(-cosmic_id) %>% 
  as.matrix() %>% 
  rob.cor.mcmc(model = model_in) %>% 
    return()
}

```


I start a benchmark. 

```{r, eval = FALSE}
mcmc_benchmark <- microbenchmark(
cor_pan_mcmc <- cor_pan[c(1:2),] %>% 
  mutate(mcmc_cor = furrr::future_map2(x, y, ~ tidy_mcmc_cor(.x, .y))), 
times = 1
)
<<<<<<< HEAD
=======
```


With the current settings, the inference on a single feature split would take 52 hours. I try to speed things up a bit. 

```{r, eval = FALSE}
plan(multiprocess)

mcmc_benchmark_parallel <- microbenchmark(
cor_pan_mcmc <- cor_pan[c(1:20),] %>% 
  mutate(mcmc_cor = furrr::future_map2(x, y, ~ tidy_mcmc_cor(.x, .y)), .progress = TRUE),
times = 1
)
```

By using the *futures* package, I can accelerate the sampling to 1.75 seconds per job, reducing the full correlation to ~10h per split. 

With the current settings, the inference on a single feature split would take 52 hours. I try to speed things up a bit. 

```{r, eval = FALSE}
plan(multiprocess)

mcmc_benchmark_parallel <- microbenchmark(
cor_pan_mcmc <- cor_pan[c(1:20),] %>% 
  mutate(mcmc_cor = furrr::future_map2(x, y, ~ tidy_mcmc_cor(.x, .y)), .progress = FALSE),
times = 1
)
```

By using the *futures* package, I can accelerate the sampling to 1.75 seconds per job, reducing the full correlation to ~10h per split. 


I need to further speed things up. I limit my bayesian inference only to pairs that are amongst the lowest 5% of each splits distribution.

```{r}
df <- cor_pan %>% 
  filter(target_pathway_x != "Other" & target_pathway_y != "Other") %>%
  mutate(same = if_else(target_pathway_x == target_pathway_y, "same", "not_same")) %>%
  mutate(class_pair = paste0(target_pathway_x, "_",  target_pathway_y)) %>% 
  arrange(r)

df %>% 
  filter(same == "not_same") %>% 
  .$r %>% quantile(probs = 0.05)

df %>%
  ggplot(aes(same, r)) + 
  geom_jitter(width = 0.1, alpha = 0.3) + 
  ggsignif::geom_signif(comparisons =  list(c("same", "not_same"))) + 
  theme_classic() + 
  labs(title = "Correlation coefficients of drug sensitivities across classes",
       x = "Drug Mechanism of Action",
       subtitle = "Pairwise Pearson correlation",
       caption = "two-sided Wilcoxon Rank Sum Test") + 
  ggsave("class_difference.png", width = 6, height = 6)
  
```

With this change, a single split should be evaluated in around 40 minutes. When running the whole analysis on multiple splits, this amounts to less than 40h of computation.

I start out with the pan-cancer inference:

```{r, eval = FALSE}
plan(multiprocess)
r_cut <- cor_pan$r %>% quantile(probs = 0.05) %>% as.numeric()

cor_pan_mcmc <- cor_pan %>% 
  #filter(r <= r_cut) %>%
  mutate(mcmc_cor = furrr::future_map2(x, y, ~ tidy_mcmc_cor(.x, .y)))

saveRDS(cor_pan_mcmc, here("data/cor_pan_mcmc_full.Rds"))
```

Running this split took 25 minutes for ~ 1000 correlations. 

I perform some QC

```{r}
cor_pan_mcmc <- readRDS(here("data/cor_pan_mcmc.Rds"))

cor_pan_mcmc_df <- cor_pan_mcmc %>% 
  mutate(hpd95 = purrr::map(mcmc_cor, ~ .x$hpd95 %>% as_tibble),
         mu = purrr::map(mcmc_cor, ~ .x$stan.rho %>% as.numeric %>% mean())) %>% 
  unnest(hpd95, mu) %>% 
  mutate(delta = upper-lower) 

cor_pan_mcmc_df %>%
  ggplot(aes(r, mu)) + 
  geom_point() + 
  theme_classic() + 
  geom_abline(slope = 1, linetype = "dotted")

cor_pan_mcmc %>% 
  mutate(hpd95 = purrr::map(mcmc_cor, ~ .x$hpd95 %>% as_tibble),
         mu = purrr::map(mcmc_cor, ~ .x$stan.rho %>% as.numeric %>% mean())) %>% 
  unnest(hpd95, mu) %>% 
  mutate(delta = upper-lower) %>%
  ggplot(aes(r, mu)) + 
  geom_point() + 
  theme_classic()
```


Now I build a function to estimate coefficients for other splits, too. 

```{r}
grouping_long <- readRDS(here("data/grouping_long.Rds"))


tidy_mcmc_cor_feature <- function(var12,
                                  feature_input,
                                  groups = grouping_long,  
                                  df = crxg, model_in = correlation_model){
  #cheap workaround
  var <- var12 %>% stringr::str_split(pattern = "_") %>% unlist()
  
<<<<<<< HEAD
result <- df %>% 
=======
df %>% 
>>>>>>> dbe425953006296008bf4cea46e5ae27126a9732
    semi_join(groups %>% filter(feature == feature_input, value == 1), by = "cosmic_id") %>% 
    filter(drug_id == var[1] | drug_id == var[2]) %>% 
    select(drug_id, cosmic_id, norm_ln_ic50) %>% 
    spread(drug_id, norm_ln_ic50) %>% 
  drop_na() %>% 
  dplyr::select(-cosmic_id) %>% 
  as.matrix() %>% 
<<<<<<< HEAD
  rob.cor.mcmc(model = model_in) 

# result %>% 
#   saveRDS(file = here(paste0("data/mcmc_feature/",Sys.time(), ".Rds")))

return(result)
}

```

33k -> 55h 9:30+7h on Saturday

```{r, eval = FALSE}
plan(multiprocess)

cor_iter_mcmc <- cor_iter_df_fd %>%
  left_join(cor_iter_df_fd %>% 
              group_by(feature) %>% 
              summarise(cut = quantile(r, probs = 0.05)), by = "feature") %>% 
  filter(r <= cut) %>%
  #.[c(1:2),] %>%
  mutate(xy = paste0(x, "_", y)) %>%
  mutate(mcmc_cor = furrr::future_map2(xy, feature, ~ tidy_mcmc_cor_feature(.x, .y)))

saveRDS(cor_iter_mcmc, here("data/cor_iter_mcmc.Rds"))
=======
  rob.cor.mcmc(model = model_in) %>% 
    return()
}



```


```{r}
cor_iter_mcmc <- cor_iter_df_fd %>%
  left_join(cor_iter_df_fd %>% group_by(feature) %>% summarise(cut = quantile(r, probs = 0.05))) %>% 
  filter(r <= cut) %>%
  mutate(xy = paste0(x, "_", y)) %>%
  mutate(mcmc_cor = furrr::future_map2(xy, feature, ~ tidy_mcmc_cor_feature(.x, .y)))
>>>>>>> dbe425953006296008bf4cea46e5ae27126a9732
```


```{r}
<<<<<<< HEAD
cor_iter_mcmc <- readRDS(here("data/cor_iter_mcmc.Rds"))

cor_iter_mcmc_df <- cor_iter_mcmc %>% 
  mutate(hpd95 = purrr::map(mcmc_cor, ~ .x$hpd95 %>% as_tibble),
         mu = purrr::map(mcmc_cor, ~ .x$stan.rho %>% as.numeric %>% mean())) %>% 
  unnest(hpd95, mu) %>% 
  mutate(delta = upper-lower)
```

```{r}
cor_iter_mcmc_df %>%
  ggplot(aes(r, mu, color = log_percent_feature )) + 
  geom_point(alpha = 0.4) + 
  theme_classic() + 
  geom_abline(slope = 1, linetype = "dotted") + 
  labs(title = "Correction of correlation coefficients after MCMC",
       subtitle = "Shown are estimates based on different sample size",
       color = "Sample size \n[log percent all cell lines]",
       caption = "MCMC from estimated bivariate t-distribution",
       y = "Mean of rho distribution",
       x = "Initial Pearson correlation") + 
  ggsave("correlation_correction_iter.png", width = 4, height = 4)
```

Now, I test which of these correlation pairs are significantly different in a specific subset compared to the pan-cancer approach. This way, I can isolate subgroup-specific patterns of anti-correlation. 

```{r}


cor_iter_mcmc_df %>% 
  left_join(cor_pan_mcmc_df %>% 
  dplyr::select(x,y,lower_pan = lower, upper_pan = upper))



```


```{r}
tmp <- cor_iter_mcmc_df %>% 
 filter(log_percent_feature > 1.3) %>% 
  arrange(feature, mu) %>% 
  dplyr::select(mu, contains("target_pathway"), feature, everything()) %>% 
  nest(-feature)


```

```{r}
library(patchwork)
cor_iter_mcmc_df %>% 
  ggplot(aes(log_percent_feature, r)) + 
  geom_point() + 
cor_iter_mcmc_df %>% 
  ggplot(aes(log_percent_feature, mu)) + 
  geom_point() 
```

```{r}
fancy_correlation <- function(var1, var2, gene){ 
  gene_s = sym(gene)

mutation_df <- mutation %>% 
  mutate(mutation = if_else(!!gene_s == 1, gene, "WT"),
         mutation = if_else(is.na(mutation), "WT", mutation),
         mutation = factor(mutation, levels = c(gene, "WT"))) %>% 
  dplyr::select(mutation, cosmic_id) 

name_1 = crxg %>% filter(drug_id == var1) %>% .$drug_name %>% unique()
name_2 = crxg %>% filter(drug_id == var2) %>% .$drug_name %>% unique()

  crxg %>% 
    filter(drug_id == var1 | drug_id == var2) %>% 
    select_(.dots = c("drug_id", "cosmic_id", "norm_ln_ic50")) %>% 
    spread(drug_id, norm_ln_ic50) %>% 
    magrittr::set_colnames(c("cosmic_id", "drug_1", "drug_2")) %>%
    mutate(cosmic_id = cosmic_id %>% as.character()) %>%
    left_join(mutation_df, by = "cosmic_id") %>%
    drop_na() %>%
    ggplot(aes(drug_1, drug_2, color = mutation)) +
      geom_point() + 
      theme_classic() +
  labs(x = name_1,
       y = name_2,
       title = "Anticorrelation of AKT and MEK inhibition",
       caption = ">20E4 drug-drug pairs across all celllines") + 
  geom_hline(yintercept = 0, linetype = "dashed") + 
  geom_vline(xintercept = 0, linetype = "dashed") + 
    scale_color_manual(values = c(RColorBrewer::brewer.pal(3, "Set1")[1], "#808080"))
}
```


```{r}
var1 = 1023 #gw441756 NGF receptor tyrosine kinase A (TrkA)
var2 =1062 #selumetinib


crxg %>% 
    filter(drug_id == var1 | drug_id == var2) %>% 
    select_(.dots = c("drug_id", "cosmic_id", "norm_ln_ic50")) %>% 
    spread(drug_id, norm_ln_ic50) %>% 
    magrittr::set_colnames(c("cosmic_id", "drug_1", "drug_2")) %>%
    #mutate(cosmic_id = cosmic_id %>% as.character()) %>%
    left_join(covariates, by = "cosmic_id") %>%
  mutate(melanoma = factor(melanoma)) %>%
    drop_na() %>%
    ggplot(aes(drug_1, drug_2, color = melanoma)) +
      geom_point() + 
      theme_classic() +
  labs(x = "gsk690693 [PI3K/MTOR]",
       y = "refametinib [MEK]",
       title = "Anticorrelation of AKT and MEK inhibition",
       caption = ">20E4 drug-drug pairs across all celllines") + 
  geom_hline(yintercept = 0, linetype = "dashed") + 
  geom_vline(xintercept = 0, linetype = "dashed") + 
    scale_color_manual(values = c( "#808080",RColorBrewer::brewer.pal(3, "Set1")[1])) +
  ggsave("melanoma_anno.png", width = 5, height = 4) 
```


```{r}
fancy_correlation(182, 1261, gene = "APC")
```


```{r}
plot_correlation<- function(var1, var2, df = crxg){
  df %>% 
    filter(drug_id == var1 | drug_id == var2) %>% 
    select_(.dots = c("drug_id", "cosmic_id", "norm_ln_ic50")) %>% 
    spread(drug_id, norm_ln_ic50) %>% 
    magrittr::set_colnames(c("cosmic_id", "drug_1", "drug_2")) %>%
    ggplot(aes(drug_1, drug_2)) +
      geom_point() + 
      theme_classic() + 
    labs()
}

var1 = 1023 
var2 =1062 

mutation_df <- mutation %>% 
  dplyr::select(KDM6A, cosmic_id) %>% 
  mutate(mutation = if_else(KDM6A == 1, "KDM6A-mutant", "WT"),
         mutation = if_else(is.na(mutation), "WT", mutation),
         mutation = factor(mutation))

  crxg %>% 
    filter(drug_id == var1 | drug_id == var2) %>% 
    select_(.dots = c("drug_id", "cosmic_id", "norm_ln_ic50")) %>% 
    spread(drug_id, norm_ln_ic50) %>% 
    magrittr::set_colnames(c("cosmic_id", "drug_1", "drug_2")) %>%
    mutate(cosmic_id = cosmic_id %>% as.character()) %>%
    left_join(mutation_df, by = "cosmic_id") %>%
    drop_na() %>%
    ggplot(aes(drug_1, drug_2, color = mutation)) +
      geom_point() + 
      theme_classic() +
  labs(x = "gsk690693 [PI3K/MTOR]",
       y = "refametinib [MEK]",
       title = "Anticorrelation of AKT and MEK inhibition",
       caption = ">20E4 drug-drug pairs across all celllines") + 
  geom_hline(yintercept = 0, linetype = "dashed") + 
  geom_vline(xintercept = 0, linetype = "dashed") + 
    scale_color_manual(values = c(RColorBrewer::brewer.pal(3, "Set1"), "#808080")) +
  ggsave("KDM6_pancancer_anno.png", width = 5, height = 4) 
=======
cor_iter_mcmc %>% 
  mutate(hpd95 = purrr::map(mcmc_cor, ~ .x$hpd95 %>% as_tibble),
         mu = purrr::map(mcmc_cor, ~ .x$stan.rho %>% as.numeric %>% mean())) %>% 
  unnest(hpd95, mu) %>% 
  mutate(delta = upper-lower) %>%
  ggplot(aes(r, mu)) + 
  geom_point() + 
  theme_classic() + 
  geom_abline(slope = 1)
>>>>>>> dbe425953006296008bf4cea46e5ae27126a9732
```

